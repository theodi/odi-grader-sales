{"id":"node_modules/ajv/dist/vocabularies/jtd/discriminator.js","dependencies":[{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/discriminator.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/lib/vocabularies/jtd/discriminator.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/package.json","includedInParent":true,"mtime":1649847102319},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/package.json","includedInParent":true,"mtime":1648635397345},{"name":"../../compile/codegen","loc":{"line":3,"column":26,"index":103},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/discriminator.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/codegen/index.js"},{"name":"./metadata","loc":{"line":4,"column":27,"index":156},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/discriminator.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/metadata.js"},{"name":"./nullable","loc":{"line":5,"column":27,"index":198},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/discriminator.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/nullable.js"},{"name":"./error","loc":{"line":6,"column":24,"index":237},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/discriminator.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/error.js"},{"name":"../discriminator/types","loc":{"line":7,"column":24,"index":273},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/discriminator.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/discriminator/types.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst metadata_1 = require(\"./metadata\");\nconst nullable_1 = require(\"./nullable\");\nconst error_1 = require(\"./error\");\nconst types_1 = require(\"../discriminator/types\");\nconst error = {\n    message: (cxt) => {\n        const { schema, params } = cxt;\n        return params.discrError\n            ? params.discrError === types_1.DiscrError.Tag\n                ? `tag \"${schema}\" must be string`\n                : `value of tag \"${schema}\" must be in mapping`\n            : (0, error_1.typeErrorMessage)(cxt, \"object\");\n    },\n    params: (cxt) => {\n        const { schema, params } = cxt;\n        return params.discrError\n            ? (0, codegen_1._) `{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}`\n            : (0, error_1.typeErrorParams)(cxt, \"object\");\n    },\n};\nconst def = {\n    keyword: \"discriminator\",\n    schemaType: \"string\",\n    implements: [\"mapping\"],\n    error,\n    code(cxt) {\n        (0, metadata_1.checkMetadata)(cxt);\n        const { gen, data, schema, parentSchema } = cxt;\n        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);\n        gen.if(cond);\n        validateDiscriminator();\n        gen.elseIf((0, codegen_1.not)(valid));\n        cxt.error();\n        gen.endIf();\n        cxt.ok(valid);\n        function validateDiscriminator() {\n            const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(schema)}`);\n            gen.if((0, codegen_1._) `${tag} === undefined`);\n            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });\n            gen.elseIf((0, codegen_1._) `typeof ${tag} == \"string\"`);\n            validateMapping(tag);\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });\n            gen.endIf();\n        }\n        function validateMapping(tag) {\n            gen.if(false);\n            for (const tagValue in parentSchema.mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(tagValue));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: \"mapping\", parentSchema: true });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            cxt.subschema({\n                keyword: \"mapping\",\n                schemaProp,\n                jtdDiscriminator: schema,\n            }, _valid);\n            return _valid;\n        }\n    },\n};\nexports.default = def;\n"},"sourceMaps":{"js":{"version":3,"file":"discriminator.js","sourceRoot":"","sources":["../../../lib/vocabularies/jtd/discriminator.ts"],"names":[],"mappings":"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","sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not, getProperty, Name} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullableObject} from \"./nullable\"\nimport {typeErrorMessage, typeErrorParams, _JTDTypeError} from \"./error\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\n\nexport type JTDDiscriminatorError =\n  | _JTDTypeError<\"discriminator\", \"object\", string>\n  | DiscrErrorObj<DiscrError.Tag>\n  | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: (cxt) => {\n    const {schema, params} = cxt\n    return params.discrError\n      ? params.discrError === DiscrError.Tag\n        ? `tag \"${schema}\" must be string`\n        : `value of tag \"${schema}\" must be in mapping`\n      : typeErrorMessage(cxt, \"object\")\n  },\n  params: (cxt) => {\n    const {schema, params} = cxt\n    return params.discrError\n      ? _`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}`\n      : typeErrorParams(cxt, \"object\")\n  },\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  schemaType: \"string\",\n  implements: [\"mapping\"],\n  error,\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema, parentSchema} = cxt\n    const [valid, cond] = checkNullableObject(cxt, data)\n\n    gen.if(cond)\n    validateDiscriminator()\n    gen.elseIf(not(valid))\n    cxt.error()\n    gen.endIf()\n    cxt.ok(valid)\n\n    function validateDiscriminator(): void {\n      const tag = gen.const(\"tag\", _`${data}${getProperty(schema)}`)\n      gen.if(_`${tag} === undefined`)\n      cxt.error(false, {discrError: DiscrError.Tag, tag})\n      gen.elseIf(_`typeof ${tag} == \"string\"`)\n      validateMapping(tag)\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Tag, tag}, {instancePath: schema})\n      gen.endIf()\n    }\n\n    function validateMapping(tag: Name): void {\n      gen.if(false)\n      for (const tagValue in parentSchema.mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(tagValue))\n      }\n      gen.else()\n      cxt.error(\n        false,\n        {discrError: DiscrError.Mapping, tag},\n        {instancePath: schema, schemaPath: \"mapping\", parentSchema: true}\n      )\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp: string): Name {\n      const _valid = gen.name(\"valid\")\n      cxt.subschema(\n        {\n          keyword: \"mapping\",\n          schemaProp,\n          jtdDiscriminator: schema,\n        },\n        _valid\n      )\n      return _valid\n    }\n  },\n}\n\nexport default def\n"]}},"error":null,"hash":"092c7245198859bdfa9ac4f7e8d828d7","cacheData":{"env":{}}}