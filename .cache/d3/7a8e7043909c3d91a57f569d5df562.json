{"id":"node_modules/ajv/dist/vocabularies/jtd/type.js","dependencies":[{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/type.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/lib/vocabularies/jtd/type.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/package.json","includedInParent":true,"mtime":1649847102319},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/package.json","includedInParent":true,"mtime":1648635397345},{"name":"../../compile/codegen","loc":{"line":4,"column":26,"index":130},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/type.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/codegen/index.js"},{"name":"../../runtime/timestamp","loc":{"line":5,"column":28,"index":184},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/type.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/runtime/timestamp.js"},{"name":"../../compile/util","loc":{"line":6,"column":23,"index":235},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/type.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/util.js"},{"name":"./metadata","loc":{"line":7,"column":27,"index":285},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/type.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/metadata.js"},{"name":"./error","loc":{"line":8,"column":24,"index":324},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/type.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/error.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.intRange = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst timestamp_1 = require(\"../../runtime/timestamp\");\nconst util_1 = require(\"../../compile/util\");\nconst metadata_1 = require(\"./metadata\");\nconst error_1 = require(\"./error\");\nexports.intRange = {\n    int8: [-128, 127, 3],\n    uint8: [0, 255, 3],\n    int16: [-32768, 32767, 5],\n    uint16: [0, 65535, 5],\n    int32: [-2147483648, 2147483647, 10],\n    uint32: [0, 4294967295, 10],\n};\nconst error = {\n    message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),\n    params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema),\n};\nfunction timestampCode(cxt) {\n    const { gen, data, it } = cxt;\n    const { timestamp, allowDate } = it.opts;\n    if (timestamp === \"date\")\n        return (0, codegen_1._) `${data} instanceof Date `;\n    const vts = (0, util_1.useFunc)(gen, timestamp_1.default);\n    const allowDateArg = allowDate ? (0, codegen_1._) `, true` : codegen_1.nil;\n    const validString = (0, codegen_1._) `typeof ${data} == \"string\" && ${vts}(${data}${allowDateArg})`;\n    return timestamp === \"string\" ? validString : (0, codegen_1.or)((0, codegen_1._) `${data} instanceof Date`, validString);\n}\nconst def = {\n    keyword: \"type\",\n    schemaType: \"string\",\n    error,\n    code(cxt) {\n        (0, metadata_1.checkMetadata)(cxt);\n        const { data, schema, parentSchema, it } = cxt;\n        let cond;\n        switch (schema) {\n            case \"boolean\":\n            case \"string\":\n                cond = (0, codegen_1._) `typeof ${data} == ${schema}`;\n                break;\n            case \"timestamp\": {\n                cond = timestampCode(cxt);\n                break;\n            }\n            case \"float32\":\n            case \"float64\":\n                cond = (0, codegen_1._) `typeof ${data} == \"number\"`;\n                break;\n            default: {\n                const sch = schema;\n                cond = (0, codegen_1._) `typeof ${data} == \"number\" && isFinite(${data}) && !(${data} % 1)`;\n                if (!it.opts.int32range && (sch === \"int32\" || sch === \"uint32\")) {\n                    if (sch === \"uint32\")\n                        cond = (0, codegen_1._) `${cond} && ${data} >= 0`;\n                }\n                else {\n                    const [min, max] = exports.intRange[sch];\n                    cond = (0, codegen_1._) `${cond} && ${data} >= ${min} && ${data} <= ${max}`;\n                }\n            }\n        }\n        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._) `${data} === null`, cond) : cond);\n    },\n};\nexports.default = def;\n"},"sourceMaps":{"js":{"version":3,"file":"type.js","sourceRoot":"","sources":["../../../lib/vocabularies/jtd/type.ts"],"names":[],"mappings":"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","sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, nil, or, Code} from \"../../compile/codegen\"\nimport validTimestamp from \"../../runtime/timestamp\"\nimport {useFunc} from \"../../compile/util\"\nimport {checkMetadata} from \"./metadata\"\nimport {typeErrorMessage, typeErrorParams, _JTDTypeError} from \"./error\"\n\nexport type JTDTypeError = _JTDTypeError<\"type\", JTDType, JTDType>\n\nexport type IntType = \"int8\" | \"uint8\" | \"int16\" | \"uint16\" | \"int32\" | \"uint32\"\n\nexport const intRange: {[T in IntType]: [number, number, number]} = {\n  int8: [-128, 127, 3],\n  uint8: [0, 255, 3],\n  int16: [-32768, 32767, 5],\n  uint16: [0, 65535, 5],\n  int32: [-2147483648, 2147483647, 10],\n  uint32: [0, 4294967295, 10],\n}\n\nexport type JTDType = \"boolean\" | \"string\" | \"timestamp\" | \"float32\" | \"float64\" | IntType\n\nconst error: KeywordErrorDefinition = {\n  message: (cxt) => typeErrorMessage(cxt, cxt.schema),\n  params: (cxt) => typeErrorParams(cxt, cxt.schema),\n}\n\nfunction timestampCode(cxt: KeywordCxt): Code {\n  const {gen, data, it} = cxt\n  const {timestamp, allowDate} = it.opts\n  if (timestamp === \"date\") return _`${data} instanceof Date `\n  const vts = useFunc(gen, validTimestamp)\n  const allowDateArg = allowDate ? _`, true` : nil\n  const validString = _`typeof ${data} == \"string\" && ${vts}(${data}${allowDateArg})`\n  return timestamp === \"string\" ? validString : or(_`${data} instanceof Date`, validString)\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"type\",\n  schemaType: \"string\",\n  error,\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {data, schema, parentSchema, it} = cxt\n    let cond: Code\n    switch (schema) {\n      case \"boolean\":\n      case \"string\":\n        cond = _`typeof ${data} == ${schema}`\n        break\n      case \"timestamp\": {\n        cond = timestampCode(cxt)\n        break\n      }\n      case \"float32\":\n      case \"float64\":\n        cond = _`typeof ${data} == \"number\"`\n        break\n      default: {\n        const sch = schema as IntType\n        cond = _`typeof ${data} == \"number\" && isFinite(${data}) && !(${data} % 1)`\n        if (!it.opts.int32range && (sch === \"int32\" || sch === \"uint32\")) {\n          if (sch === \"uint32\") cond = _`${cond} && ${data} >= 0`\n        } else {\n          const [min, max] = intRange[sch]\n          cond = _`${cond} && ${data} >= ${min} && ${data} <= ${max}`\n        }\n      }\n    }\n    cxt.pass(parentSchema.nullable ? or(_`${data} === null`, cond) : cond)\n  },\n}\n\nexport default def\n"]}},"error":null,"hash":"44ed369e32cb480f3f999e8e9bff1c1b","cacheData":{"env":{}}}