{"id":"node_modules/ajv/dist/vocabularies/jtd/ref.js","dependencies":[{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/ref.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/lib/vocabularies/jtd/ref.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/package.json","includedInParent":true,"mtime":1649847102319},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/package.json","includedInParent":true,"mtime":1648635397345},{"name":"../../compile","loc":{"line":4,"column":26,"index":128},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/ref.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/index.js"},{"name":"../../compile/codegen","loc":{"line":5,"column":26,"index":172},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/ref.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/codegen/index.js"},{"name":"../../compile/ref_error","loc":{"line":6,"column":28,"index":226},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/ref.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/ref_error.js"},{"name":"../../compile/names","loc":{"line":7,"column":24,"index":278},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/ref.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/names.js"},{"name":"../core/ref","loc":{"line":8,"column":22,"index":324},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/ref.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/core/ref.js"},{"name":"./metadata","loc":{"line":9,"column":27,"index":367},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/ref.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/metadata.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasRef = void 0;\nconst compile_1 = require(\"../../compile\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst names_1 = require(\"../../compile/names\");\nconst ref_1 = require(\"../core/ref\");\nconst metadata_1 = require(\"./metadata\");\nconst def = {\n    keyword: \"ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        (0, metadata_1.checkMetadata)(cxt);\n        const { gen, data, schema: ref, parentSchema, it } = cxt;\n        const { schemaEnv: { root }, } = it;\n        const valid = gen.name(\"valid\");\n        if (parentSchema.nullable) {\n            gen.var(valid, (0, codegen_1._) `${data} === null`);\n            gen.if((0, codegen_1.not)(valid), validateJtdRef);\n        }\n        else {\n            gen.var(valid, false);\n            validateJtdRef();\n        }\n        cxt.ok(valid);\n        function validateJtdRef() {\n            var _a;\n            const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];\n            if (!refSchema) {\n                throw new ref_error_1.default(it.opts.uriResolver, \"\", ref, `No definition ${ref}`);\n            }\n            if (hasRef(refSchema) || !it.opts.inlineRefs)\n                callValidate(refSchema);\n            else\n                inlineRefSchema(refSchema);\n        }\n        function callValidate(schema) {\n            const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));\n            const v = (0, ref_1.getValidate)(cxt, sch);\n            const errsCount = gen.const(\"_errs\", names_1.default.errors);\n            (0, ref_1.callRef)(cxt, v, sch, sch.$async);\n            gen.assign(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        }\n        function inlineRefSchema(schema) {\n            const schName = gen.scopeValue(\"schema\", it.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });\n            cxt.subschema({\n                schema,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: `/definitions/${ref}`,\n            }, valid);\n        }\n    },\n};\nfunction hasRef(schema) {\n    for (const key in schema) {\n        let sch;\n        if (key === \"ref\" || (typeof (sch = schema[key]) == \"object\" && hasRef(sch)))\n            return true;\n    }\n    return false;\n}\nexports.hasRef = hasRef;\nexports.default = def;\n"},"sourceMaps":{"js":{"version":3,"file":"ref.js","sourceRoot":"","sources":["../../../lib/vocabularies/jtd/ref.ts"],"names":[],"mappings":"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","sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {compileSchema, SchemaEnv} from \"../../compile\"\nimport {_, not, nil, stringify} from \"../../compile/codegen\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport N from \"../../compile/names\"\nimport {getValidate, callRef} from \"../core/ref\"\nimport {checkMetadata} from \"./metadata\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema: ref, parentSchema, it} = cxt\n    const {\n      schemaEnv: {root},\n    } = it\n    const valid = gen.name(\"valid\")\n    if (parentSchema.nullable) {\n      gen.var(valid, _`${data} === null`)\n      gen.if(not(valid), validateJtdRef)\n    } else {\n      gen.var(valid, false)\n      validateJtdRef()\n    }\n    cxt.ok(valid)\n\n    function validateJtdRef(): void {\n      const refSchema = (root.schema as AnySchemaObject).definitions?.[ref]\n      if (!refSchema) {\n        throw new MissingRefError(it.opts.uriResolver, \"\", ref, `No definition ${ref}`)\n      }\n      if (hasRef(refSchema) || !it.opts.inlineRefs) callValidate(refSchema)\n      else inlineRefSchema(refSchema)\n    }\n\n    function callValidate(schema: AnySchemaObject): void {\n      const sch = compileSchema.call(\n        it.self,\n        new SchemaEnv({schema, root, schemaPath: `/definitions/${ref}`})\n      )\n      const v = getValidate(cxt, sch)\n      const errsCount = gen.const(\"_errs\", N.errors)\n      callRef(cxt, v, sch, sch.$async)\n      gen.assign(valid, _`${errsCount} === ${N.errors}`)\n    }\n\n    function inlineRefSchema(schema: AnySchemaObject): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        it.opts.code.source === true ? {ref: schema, code: stringify(schema)} : {ref: schema}\n      )\n      cxt.subschema(\n        {\n          schema,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: `/definitions/${ref}`,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport function hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    let sch: AnySchemaObject\n    if (key === \"ref\" || (typeof (sch = schema[key]) == \"object\" && hasRef(sch))) return true\n  }\n  return false\n}\n\nexport default def\n"]}},"error":null,"hash":"63fe63d026c9a58ae7dc0b16af637586","cacheData":{"env":{}}}