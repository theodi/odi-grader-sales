{"id":"node_modules/ajv/dist/compile/jtd/parse.js","dependencies":[{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/lib/compile/jtd/parse.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/package.json","includedInParent":true,"mtime":1649847102319},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/package.json","includedInParent":true,"mtime":1648635397345},{"name":"./types","loc":{"line":3,"column":24,"index":101},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/types.js"},{"name":"..","loc":{"line":4,"column":20,"index":133},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/index.js"},{"name":"../codegen","loc":{"line":5,"column":26,"index":166},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/codegen/index.js"},{"name":"../ref_error","loc":{"line":6,"column":28,"index":209},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/ref_error.js"},{"name":"../names","loc":{"line":7,"column":24,"index":250},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/names.js"},{"name":"../../vocabularies/code","loc":{"line":8,"column":23,"index":286},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/code.js"},{"name":"../../vocabularies/jtd/ref","loc":{"line":9,"column":22,"index":336},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/ref.js"},{"name":"../../vocabularies/jtd/type","loc":{"line":10,"column":23,"index":390},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/jtd/type.js"},{"name":"../../runtime/parseJson","loc":{"line":11,"column":28,"index":450},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/runtime/parseJson.js"},{"name":"../util","loc":{"line":12,"column":23,"index":501},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/util.js"},{"name":"../../runtime/timestamp","loc":{"line":13,"column":28,"index":541},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/jtd/parse.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/runtime/timestamp.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst types_1 = require(\"./types\");\nconst __1 = require(\"..\");\nconst codegen_1 = require(\"../codegen\");\nconst ref_error_1 = require(\"../ref_error\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst ref_1 = require(\"../../vocabularies/jtd/ref\");\nconst type_1 = require(\"../../vocabularies/jtd/type\");\nconst parseJson_1 = require(\"../../runtime/parseJson\");\nconst util_1 = require(\"../util\");\nconst timestamp_1 = require(\"../../runtime/timestamp\");\nconst genParse = {\n    elements: parseElements,\n    values: parseValues,\n    discriminator: parseDiscriminator,\n    properties: parseProperties,\n    optionalProperties: parseProperties,\n    enum: parseEnum,\n    type: parseType,\n    ref: parseRef,\n};\nfunction compileParser(sch, definitions) {\n    const _sch = __1.getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    const parseName = gen.scopeName(\"parse\");\n    const cxt = {\n        self: this,\n        gen,\n        schema: sch.schema,\n        schemaEnv: sch,\n        definitions,\n        data: names_1.default.data,\n        parseName,\n        char: gen.name(\"c\"),\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        sch.parseName = parseName;\n        parserFunction(cxt);\n        gen.optimize(this.opts.code.optimize);\n        const parseFuncCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;\n        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);\n        const parse = makeParse(this.scope.get());\n        this.scope.value(parseName, { ref: parse });\n        sch.parse = parse;\n    }\n    catch (e) {\n        if (sourceCode)\n            this.logger.error(\"Error compiling parser, function code:\", sourceCode);\n        delete sch.parse;\n        delete sch.parseName;\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n    return sch;\n}\nexports.default = compileParser;\nconst undef = (0, codegen_1._) `undefined`;\nfunction parserFunction(cxt) {\n    const { gen, parseName, char } = cxt;\n    gen.func(parseName, (0, codegen_1._) `${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {\n        gen.let(names_1.default.data);\n        gen.let(char);\n        gen.assign((0, codegen_1._) `${parseName}.message`, undef);\n        gen.assign((0, codegen_1._) `${parseName}.position`, undef);\n        gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${names_1.default.jsonPos} || 0`);\n        gen.const(names_1.default.jsonLen, (0, codegen_1._) `${names_1.default.json}.length`);\n        parseCode(cxt);\n        skipWhitespace(cxt);\n        gen.if(names_1.default.jsonPart, () => {\n            gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);\n            gen.return(names_1.default.data);\n        });\n        gen.if((0, codegen_1._) `${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));\n        jsonSyntaxError(cxt);\n    });\n}\nfunction parseCode(cxt) {\n    let form;\n    for (const key of types_1.jtdForms) {\n        if (key in cxt.schema) {\n            form = key;\n            break;\n        }\n    }\n    if (form)\n        parseNullable(cxt, genParse[form]);\n    else\n        parseEmpty(cxt);\n}\nconst parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));\nfunction parseNullable(cxt, parseForm) {\n    const { gen, schema, data } = cxt;\n    if (!schema.nullable)\n        return parseForm(cxt);\n    tryParseToken(cxt, \"null\", parseForm, () => gen.assign(data, null));\n}\nfunction parseElements(cxt) {\n    const { gen, schema, data } = cxt;\n    parseToken(cxt, \"[\");\n    const ix = gen.let(\"i\", 0);\n    gen.assign(data, (0, codegen_1._) `[]`);\n    parseItems(cxt, \"]\", () => {\n        const el = gen.let(\"el\");\n        parseCode({ ...cxt, schema: schema.elements, data: el });\n        gen.assign((0, codegen_1._) `${data}[${ix}++]`, el);\n    });\n}\nfunction parseValues(cxt) {\n    const { gen, schema, data } = cxt;\n    parseToken(cxt, \"{\");\n    gen.assign(data, (0, codegen_1._) `{}`);\n    parseItems(cxt, \"}\", () => parseKeyValue(cxt, schema.values));\n}\nfunction parseItems(cxt, endToken, block) {\n    tryParseItems(cxt, endToken, block);\n    parseToken(cxt, endToken);\n}\nfunction tryParseItems(cxt, endToken, block) {\n    const { gen } = cxt;\n    gen.for((0, codegen_1._) `;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {\n        block();\n        tryParseToken(cxt, \",\", () => gen.break(), hasItem);\n    });\n    function hasItem() {\n        tryParseToken(cxt, endToken, () => { }, jsonSyntaxError);\n    }\n}\nfunction parseKeyValue(cxt, schema) {\n    const { gen } = cxt;\n    const key = gen.let(\"key\");\n    parseString({ ...cxt, data: key });\n    parseToken(cxt, \":\");\n    parsePropertyValue(cxt, key, schema);\n}\nfunction parseDiscriminator(cxt) {\n    const { gen, data, schema } = cxt;\n    const { discriminator, mapping } = schema;\n    parseToken(cxt, \"{\");\n    gen.assign(data, (0, codegen_1._) `{}`);\n    const startPos = gen.const(\"pos\", names_1.default.jsonPos);\n    const value = gen.let(\"value\");\n    const tag = gen.let(\"tag\");\n    tryParseItems(cxt, \"}\", () => {\n        const key = gen.let(\"key\");\n        parseString({ ...cxt, data: key });\n        parseToken(cxt, \":\");\n        gen.if((0, codegen_1._) `${key} === ${discriminator}`, () => {\n            parseString({ ...cxt, data: tag });\n            gen.assign((0, codegen_1._) `${data}[${key}]`, tag);\n            gen.break();\n        }, () => parseEmpty({ ...cxt, data: value }) // can be discarded/skipped\n        );\n    });\n    gen.assign(names_1.default.jsonPos, startPos);\n    gen.if((0, codegen_1._) `${tag} === undefined`);\n    parsingError(cxt, (0, codegen_1.str) `discriminator tag not found`);\n    for (const tagValue in mapping) {\n        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);\n    }\n    gen.else();\n    parsingError(cxt, (0, codegen_1.str) `discriminator value not in schema`);\n    gen.endIf();\n}\nfunction parseProperties(cxt) {\n    const { gen, data } = cxt;\n    parseToken(cxt, \"{\");\n    gen.assign(data, (0, codegen_1._) `{}`);\n    parseSchemaProperties(cxt);\n}\nfunction parseSchemaProperties(cxt, discriminator) {\n    const { gen, schema, data } = cxt;\n    const { properties, optionalProperties, additionalProperties } = schema;\n    parseItems(cxt, \"}\", () => {\n        const key = gen.let(\"key\");\n        parseString({ ...cxt, data: key });\n        parseToken(cxt, \":\");\n        gen.if(false);\n        parseDefinedProperty(cxt, key, properties);\n        parseDefinedProperty(cxt, key, optionalProperties);\n        if (discriminator) {\n            gen.elseIf((0, codegen_1._) `${key} === ${discriminator}`);\n            const tag = gen.let(\"tag\");\n            parseString({ ...cxt, data: tag }); // can be discarded, it is already assigned\n        }\n        gen.else();\n        if (additionalProperties) {\n            parseEmpty({ ...cxt, data: (0, codegen_1._) `${data}[${key}]` });\n        }\n        else {\n            parsingError(cxt, (0, codegen_1.str) `property ${key} not allowed`);\n        }\n        gen.endIf();\n    });\n    if (properties) {\n        const hasProp = (0, code_1.hasPropFunc)(gen);\n        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._) `${hasProp}.call(${data}, ${p})`));\n        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str) `missing required properties`));\n    }\n}\nfunction parseDefinedProperty(cxt, key, schemas = {}) {\n    const { gen } = cxt;\n    for (const prop in schemas) {\n        gen.elseIf((0, codegen_1._) `${key} === ${prop}`);\n        parsePropertyValue(cxt, key, schemas[prop]);\n    }\n}\nfunction parsePropertyValue(cxt, key, schema) {\n    parseCode({ ...cxt, schema, data: (0, codegen_1._) `${cxt.data}[${key}]` });\n}\nfunction parseType(cxt) {\n    const { gen, schema, data, self } = cxt;\n    switch (schema.type) {\n        case \"boolean\":\n            parseBoolean(cxt);\n            break;\n        case \"string\":\n            parseString(cxt);\n            break;\n        case \"timestamp\": {\n            parseString(cxt);\n            const vts = (0, util_1.useFunc)(gen, timestamp_1.default);\n            const { allowDate, parseDate } = self.opts;\n            const notValid = allowDate ? (0, codegen_1._) `!${vts}(${data}, true)` : (0, codegen_1._) `!${vts}(${data})`;\n            const fail = parseDate\n                ? (0, codegen_1.or)(notValid, (0, codegen_1._) `(${data} = new Date(${data}), false)`, (0, codegen_1._) `isNaN(${data}.valueOf())`)\n                : notValid;\n            gen.if(fail, () => parsingError(cxt, (0, codegen_1.str) `invalid timestamp`));\n            break;\n        }\n        case \"float32\":\n        case \"float64\":\n            parseNumber(cxt);\n            break;\n        default: {\n            const t = schema.type;\n            if (!self.opts.int32range && (t === \"int32\" || t === \"uint32\")) {\n                parseNumber(cxt, 16); // 2 ** 53 - max safe integer\n                if (t === \"uint32\") {\n                    gen.if((0, codegen_1._) `${data} < 0`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));\n                }\n            }\n            else {\n                const [min, max, maxDigits] = type_1.intRange[t];\n                parseNumber(cxt, maxDigits);\n                gen.if((0, codegen_1._) `${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));\n            }\n        }\n    }\n}\nfunction parseString(cxt) {\n    parseToken(cxt, '\"');\n    parseWith(cxt, parseJson_1.parseJsonString);\n}\nfunction parseEnum(cxt) {\n    const { gen, data, schema } = cxt;\n    const enumSch = schema.enum;\n    parseToken(cxt, '\"');\n    // TODO loopEnum\n    gen.if(false);\n    for (const value of enumSch) {\n        const valueStr = JSON.stringify(value).slice(1); // remove starting quote\n        gen.elseIf((0, codegen_1._) `${jsonSlice(valueStr.length)} === ${valueStr}`);\n        gen.assign(data, (0, codegen_1.str) `${value}`);\n        gen.add(names_1.default.jsonPos, valueStr.length);\n    }\n    gen.else();\n    jsonSyntaxError(cxt);\n    gen.endIf();\n}\nfunction parseNumber(cxt, maxDigits) {\n    const { gen } = cxt;\n    skipWhitespace(cxt);\n    gen.if((0, codegen_1._) `\"-0123456789\".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));\n}\nfunction parseBooleanToken(bool, fail) {\n    return (cxt) => {\n        const { gen, data } = cxt;\n        tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));\n    };\n}\nfunction parseRef(cxt) {\n    const { gen, self, definitions, schema, schemaEnv } = cxt;\n    const { ref } = schema;\n    const refSchema = definitions[ref];\n    if (!refSchema)\n        throw new ref_error_1.default(self.opts.uriResolver, \"\", ref, `No definition ${ref}`);\n    if (!(0, ref_1.hasRef)(refSchema))\n        return parseCode({ ...cxt, schema: refSchema });\n    const { root } = schemaEnv;\n    const sch = compileParser.call(self, new __1.SchemaEnv({ schema: refSchema, root }), definitions);\n    partialParse(cxt, getParser(gen, sch), true);\n}\nfunction getParser(gen, sch) {\n    return sch.parse\n        ? gen.scopeValue(\"parse\", { ref: sch.parse })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.parse`;\n}\nfunction parseEmpty(cxt) {\n    parseWith(cxt, parseJson_1.parseJson);\n}\nfunction parseWith(cxt, parseFunc, args) {\n    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);\n}\nfunction partialParse(cxt, parseFunc, args) {\n    const { gen, data } = cxt;\n    gen.assign(data, (0, codegen_1._) `${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._) `, ${args}` : codegen_1.nil})`);\n    gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${parseFunc}.position`);\n    gen.if((0, codegen_1._) `${data} === undefined`, () => parsingError(cxt, (0, codegen_1._) `${parseFunc}.message`));\n}\nfunction parseToken(cxt, tok) {\n    tryParseToken(cxt, tok, jsonSyntaxError);\n}\nfunction tryParseToken(cxt, tok, fail, success) {\n    const { gen } = cxt;\n    const n = tok.length;\n    skipWhitespace(cxt);\n    gen.if((0, codegen_1._) `${jsonSlice(n)} === ${tok}`, () => {\n        gen.add(names_1.default.jsonPos, n);\n        success === null || success === void 0 ? void 0 : success(cxt);\n    }, () => fail(cxt));\n}\nfunction skipWhitespace({ gen, char: c }) {\n    gen.code((0, codegen_1._) `while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===\" \"||${c}===\"\\\\n\"||${c}===\"\\\\r\"||${c}===\"\\\\t\"))${names_1.default.jsonPos}++;`);\n}\nfunction jsonSlice(len) {\n    return len === 1\n        ? (0, codegen_1._) `${names_1.default.json}[${names_1.default.jsonPos}]`\n        : (0, codegen_1._) `${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;\n}\nfunction jsonSyntaxError(cxt) {\n    parsingError(cxt, (0, codegen_1._) `\"unexpected token \" + ${names_1.default.json}[${names_1.default.jsonPos}]`);\n}\nfunction parsingError({ gen, parseName }, msg) {\n    gen.assign((0, codegen_1._) `${parseName}.message`, msg);\n    gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);\n    gen.return(undef);\n}\n"},"sourceMaps":{"js":{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../lib/compile/jtd/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import type Ajv from \"../../core\"\nimport type {SchemaObject} from \"../../types\"\nimport {jtdForms, JTDForm, SchemaObjectMap} from \"./types\"\nimport {SchemaEnv, getCompilingSchema} from \"..\"\nimport {_, str, and, or, nil, not, CodeGen, Code, Name, SafeExpr} from \"../codegen\"\nimport MissingRefError from \"../ref_error\"\nimport N from \"../names\"\nimport {hasPropFunc} from \"../../vocabularies/code\"\nimport {hasRef} from \"../../vocabularies/jtd/ref\"\nimport {intRange, IntType} from \"../../vocabularies/jtd/type\"\nimport {parseJson, parseJsonNumber, parseJsonString} from \"../../runtime/parseJson\"\nimport {useFunc} from \"../util\"\nimport validTimestamp from \"../../runtime/timestamp\"\n\ntype GenParse = (cxt: ParseCxt) => void\n\nconst genParse: {[F in JTDForm]: GenParse} = {\n  elements: parseElements,\n  values: parseValues,\n  discriminator: parseDiscriminator,\n  properties: parseProperties,\n  optionalProperties: parseProperties,\n  enum: parseEnum,\n  type: parseType,\n  ref: parseRef,\n}\n\ninterface ParseCxt {\n  readonly gen: CodeGen\n  readonly self: Ajv // current Ajv instance\n  readonly schemaEnv: SchemaEnv\n  readonly definitions: SchemaObjectMap\n  schema: SchemaObject\n  data: Code\n  parseName: Name\n  char: Name\n}\n\nexport default function compileParser(\n  this: Ajv,\n  sch: SchemaEnv,\n  definitions: SchemaObjectMap\n): SchemaEnv {\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  const parseName = gen.scopeName(\"parse\")\n  const cxt: ParseCxt = {\n    self: this,\n    gen,\n    schema: sch.schema as SchemaObject,\n    schemaEnv: sch,\n    definitions,\n    data: N.data,\n    parseName,\n    char: gen.name(\"c\"),\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    sch.parseName = parseName\n    parserFunction(cxt)\n    gen.optimize(this.opts.code.optimize)\n    const parseFuncCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${parseFuncCode}`\n    const makeParse = new Function(`${N.scope}`, sourceCode)\n    const parse: (json: string) => unknown = makeParse(this.scope.get())\n    this.scope.value(parseName, {ref: parse})\n    sch.parse = parse\n  } catch (e) {\n    if (sourceCode) this.logger.error(\"Error compiling parser, function code:\", sourceCode)\n    delete sch.parse\n    delete sch.parseName\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n  return sch\n}\n\nconst undef = _`undefined`\n\nfunction parserFunction(cxt: ParseCxt): void {\n  const {gen, parseName, char} = cxt\n  gen.func(parseName, _`${N.json}, ${N.jsonPos}, ${N.jsonPart}`, false, () => {\n    gen.let(N.data)\n    gen.let(char)\n    gen.assign(_`${parseName}.message`, undef)\n    gen.assign(_`${parseName}.position`, undef)\n    gen.assign(N.jsonPos, _`${N.jsonPos} || 0`)\n    gen.const(N.jsonLen, _`${N.json}.length`)\n    parseCode(cxt)\n    skipWhitespace(cxt)\n    gen.if(N.jsonPart, () => {\n      gen.assign(_`${parseName}.position`, N.jsonPos)\n      gen.return(N.data)\n    })\n    gen.if(_`${N.jsonPos} === ${N.jsonLen}`, () => gen.return(N.data))\n    jsonSyntaxError(cxt)\n  })\n}\n\nfunction parseCode(cxt: ParseCxt): void {\n  let form: JTDForm | undefined\n  for (const key of jtdForms) {\n    if (key in cxt.schema) {\n      form = key\n      break\n    }\n  }\n  if (form) parseNullable(cxt, genParse[form])\n  else parseEmpty(cxt)\n}\n\nconst parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError))\n\nfunction parseNullable(cxt: ParseCxt, parseForm: GenParse): void {\n  const {gen, schema, data} = cxt\n  if (!schema.nullable) return parseForm(cxt)\n  tryParseToken(cxt, \"null\", parseForm, () => gen.assign(data, null))\n}\n\nfunction parseElements(cxt: ParseCxt): void {\n  const {gen, schema, data} = cxt\n  parseToken(cxt, \"[\")\n  const ix = gen.let(\"i\", 0)\n  gen.assign(data, _`[]`)\n  parseItems(cxt, \"]\", () => {\n    const el = gen.let(\"el\")\n    parseCode({...cxt, schema: schema.elements, data: el})\n    gen.assign(_`${data}[${ix}++]`, el)\n  })\n}\n\nfunction parseValues(cxt: ParseCxt): void {\n  const {gen, schema, data} = cxt\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  parseItems(cxt, \"}\", () => parseKeyValue(cxt, schema.values))\n}\n\nfunction parseItems(cxt: ParseCxt, endToken: string, block: () => void): void {\n  tryParseItems(cxt, endToken, block)\n  parseToken(cxt, endToken)\n}\n\nfunction tryParseItems(cxt: ParseCxt, endToken: string, block: () => void): void {\n  const {gen} = cxt\n  gen.for(_`;${N.jsonPos}<${N.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {\n    block()\n    tryParseToken(cxt, \",\", () => gen.break(), hasItem)\n  })\n\n  function hasItem(): void {\n    tryParseToken(cxt, endToken, () => {}, jsonSyntaxError)\n  }\n}\n\nfunction parseKeyValue(cxt: ParseCxt, schema: SchemaObject): void {\n  const {gen} = cxt\n  const key = gen.let(\"key\")\n  parseString({...cxt, data: key})\n  parseToken(cxt, \":\")\n  parsePropertyValue(cxt, key, schema)\n}\n\nfunction parseDiscriminator(cxt: ParseCxt): void {\n  const {gen, data, schema} = cxt\n  const {discriminator, mapping} = schema\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  const startPos = gen.const(\"pos\", N.jsonPos)\n  const value = gen.let(\"value\")\n  const tag = gen.let(\"tag\")\n  tryParseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\")\n    parseString({...cxt, data: key})\n    parseToken(cxt, \":\")\n    gen.if(\n      _`${key} === ${discriminator}`,\n      () => {\n        parseString({...cxt, data: tag})\n        gen.assign(_`${data}[${key}]`, tag)\n        gen.break()\n      },\n      () => parseEmpty({...cxt, data: value}) // can be discarded/skipped\n    )\n  })\n  gen.assign(N.jsonPos, startPos)\n  gen.if(_`${tag} === undefined`)\n  parsingError(cxt, str`discriminator tag not found`)\n  for (const tagValue in mapping) {\n    gen.elseIf(_`${tag} === ${tagValue}`)\n    parseSchemaProperties({...cxt, schema: mapping[tagValue]}, discriminator)\n  }\n  gen.else()\n  parsingError(cxt, str`discriminator value not in schema`)\n  gen.endIf()\n}\n\nfunction parseProperties(cxt: ParseCxt): void {\n  const {gen, data} = cxt\n  parseToken(cxt, \"{\")\n  gen.assign(data, _`{}`)\n  parseSchemaProperties(cxt)\n}\n\nfunction parseSchemaProperties(cxt: ParseCxt, discriminator?: string): void {\n  const {gen, schema, data} = cxt\n  const {properties, optionalProperties, additionalProperties} = schema\n  parseItems(cxt, \"}\", () => {\n    const key = gen.let(\"key\")\n    parseString({...cxt, data: key})\n    parseToken(cxt, \":\")\n    gen.if(false)\n    parseDefinedProperty(cxt, key, properties)\n    parseDefinedProperty(cxt, key, optionalProperties)\n    if (discriminator) {\n      gen.elseIf(_`${key} === ${discriminator}`)\n      const tag = gen.let(\"tag\")\n      parseString({...cxt, data: tag}) // can be discarded, it is already assigned\n    }\n    gen.else()\n    if (additionalProperties) {\n      parseEmpty({...cxt, data: _`${data}[${key}]`})\n    } else {\n      parsingError(cxt, str`property ${key} not allowed`)\n    }\n    gen.endIf()\n  })\n  if (properties) {\n    const hasProp = hasPropFunc(gen)\n    const allProps: Code = and(\n      ...Object.keys(properties).map((p): Code => _`${hasProp}.call(${data}, ${p})`)\n    )\n    gen.if(not(allProps), () => parsingError(cxt, str`missing required properties`))\n  }\n}\n\nfunction parseDefinedProperty(cxt: ParseCxt, key: Name, schemas: SchemaObjectMap = {}): void {\n  const {gen} = cxt\n  for (const prop in schemas) {\n    gen.elseIf(_`${key} === ${prop}`)\n    parsePropertyValue(cxt, key, schemas[prop] as SchemaObject)\n  }\n}\n\nfunction parsePropertyValue(cxt: ParseCxt, key: Name, schema: SchemaObject): void {\n  parseCode({...cxt, schema, data: _`${cxt.data}[${key}]`})\n}\n\nfunction parseType(cxt: ParseCxt): void {\n  const {gen, schema, data, self} = cxt\n  switch (schema.type) {\n    case \"boolean\":\n      parseBoolean(cxt)\n      break\n    case \"string\":\n      parseString(cxt)\n      break\n    case \"timestamp\": {\n      parseString(cxt)\n      const vts = useFunc(gen, validTimestamp)\n      const {allowDate, parseDate} = self.opts\n      const notValid = allowDate ? _`!${vts}(${data}, true)` : _`!${vts}(${data})`\n      const fail: Code = parseDate\n        ? or(notValid, _`(${data} = new Date(${data}), false)`, _`isNaN(${data}.valueOf())`)\n        : notValid\n      gen.if(fail, () => parsingError(cxt, str`invalid timestamp`))\n      break\n    }\n    case \"float32\":\n    case \"float64\":\n      parseNumber(cxt)\n      break\n    default: {\n      const t = schema.type as IntType\n      if (!self.opts.int32range && (t === \"int32\" || t === \"uint32\")) {\n        parseNumber(cxt, 16) // 2 ** 53 - max safe integer\n        if (t === \"uint32\") {\n          gen.if(_`${data} < 0`, () => parsingError(cxt, str`integer out of range`))\n        }\n      } else {\n        const [min, max, maxDigits] = intRange[t]\n        parseNumber(cxt, maxDigits)\n        gen.if(_`${data} < ${min} || ${data} > ${max}`, () =>\n          parsingError(cxt, str`integer out of range`)\n        )\n      }\n    }\n  }\n}\n\nfunction parseString(cxt: ParseCxt): void {\n  parseToken(cxt, '\"')\n  parseWith(cxt, parseJsonString)\n}\n\nfunction parseEnum(cxt: ParseCxt): void {\n  const {gen, data, schema} = cxt\n  const enumSch = schema.enum\n  parseToken(cxt, '\"')\n  // TODO loopEnum\n  gen.if(false)\n  for (const value of enumSch) {\n    const valueStr = JSON.stringify(value).slice(1) // remove starting quote\n    gen.elseIf(_`${jsonSlice(valueStr.length)} === ${valueStr}`)\n    gen.assign(data, str`${value}`)\n    gen.add(N.jsonPos, valueStr.length)\n  }\n  gen.else()\n  jsonSyntaxError(cxt)\n  gen.endIf()\n}\n\nfunction parseNumber(cxt: ParseCxt, maxDigits?: number): void {\n  const {gen} = cxt\n  skipWhitespace(cxt)\n  gen.if(\n    _`\"-0123456789\".indexOf(${jsonSlice(1)}) < 0`,\n    () => jsonSyntaxError(cxt),\n    () => parseWith(cxt, parseJsonNumber, maxDigits)\n  )\n}\n\nfunction parseBooleanToken(bool: boolean, fail: GenParse): GenParse {\n  return (cxt) => {\n    const {gen, data} = cxt\n    tryParseToken(\n      cxt,\n      `${bool}`,\n      () => fail(cxt),\n      () => gen.assign(data, bool)\n    )\n  }\n}\n\nfunction parseRef(cxt: ParseCxt): void {\n  const {gen, self, definitions, schema, schemaEnv} = cxt\n  const {ref} = schema\n  const refSchema = definitions[ref]\n  if (!refSchema) throw new MissingRefError(self.opts.uriResolver, \"\", ref, `No definition ${ref}`)\n  if (!hasRef(refSchema)) return parseCode({...cxt, schema: refSchema})\n  const {root} = schemaEnv\n  const sch = compileParser.call(self, new SchemaEnv({schema: refSchema, root}), definitions)\n  partialParse(cxt, getParser(gen, sch), true)\n}\n\nfunction getParser(gen: CodeGen, sch: SchemaEnv): Code {\n  return sch.parse\n    ? gen.scopeValue(\"parse\", {ref: sch.parse})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.parse`\n}\n\nfunction parseEmpty(cxt: ParseCxt): void {\n  parseWith(cxt, parseJson)\n}\n\nfunction parseWith(cxt: ParseCxt, parseFunc: {code: string}, args?: SafeExpr): void {\n  partialParse(cxt, useFunc(cxt.gen, parseFunc), args)\n}\n\nfunction partialParse(cxt: ParseCxt, parseFunc: Name, args?: SafeExpr): void {\n  const {gen, data} = cxt\n  gen.assign(data, _`${parseFunc}(${N.json}, ${N.jsonPos}${args ? _`, ${args}` : nil})`)\n  gen.assign(N.jsonPos, _`${parseFunc}.position`)\n  gen.if(_`${data} === undefined`, () => parsingError(cxt, _`${parseFunc}.message`))\n}\n\nfunction parseToken(cxt: ParseCxt, tok: string): void {\n  tryParseToken(cxt, tok, jsonSyntaxError)\n}\n\nfunction tryParseToken(cxt: ParseCxt, tok: string, fail: GenParse, success?: GenParse): void {\n  const {gen} = cxt\n  const n = tok.length\n  skipWhitespace(cxt)\n  gen.if(\n    _`${jsonSlice(n)} === ${tok}`,\n    () => {\n      gen.add(N.jsonPos, n)\n      success?.(cxt)\n    },\n    () => fail(cxt)\n  )\n}\n\nfunction skipWhitespace({gen, char: c}: ParseCxt): void {\n  gen.code(\n    _`while((${c}=${N.json}[${N.jsonPos}],${c}===\" \"||${c}===\"\\\\n\"||${c}===\"\\\\r\"||${c}===\"\\\\t\"))${N.jsonPos}++;`\n  )\n}\n\nfunction jsonSlice(len: number | Name): Code {\n  return len === 1\n    ? _`${N.json}[${N.jsonPos}]`\n    : _`${N.json}.slice(${N.jsonPos}, ${N.jsonPos}+${len})`\n}\n\nfunction jsonSyntaxError(cxt: ParseCxt): void {\n  parsingError(cxt, _`\"unexpected token \" + ${N.json}[${N.jsonPos}]`)\n}\n\nfunction parsingError({gen, parseName}: ParseCxt, msg: Code): void {\n  gen.assign(_`${parseName}.message`, msg)\n  gen.assign(_`${parseName}.position`, N.jsonPos)\n  gen.return(undef)\n}\n"]}},"error":null,"hash":"69158cf1f7aeeb4485431c5372f78888","cacheData":{"env":{}}}