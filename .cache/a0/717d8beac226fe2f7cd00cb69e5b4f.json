{"id":"node_modules/ajv/dist/vocabularies/validation/required.js","dependencies":[{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/validation/required.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/lib/vocabularies/validation/required.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/lucyknight/odi-grader-sales/package.json","includedInParent":true,"mtime":1649847102319},{"name":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/package.json","includedInParent":true,"mtime":1648635397345},{"name":"../code","loc":{"line":3,"column":23,"index":100},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/validation/required.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/code.js"},{"name":"../../compile/codegen","loc":{"line":4,"column":26,"index":138},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/validation/required.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/codegen/index.js"},{"name":"../../compile/util","loc":{"line":5,"column":23,"index":187},"parent":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/vocabularies/validation/required.js","resolved":"/Users/lucyknight/odi-grader-sales/node_modules/ajv/dist/compile/util.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n"},"sourceMaps":{"js":{"version":3,"file":"required.js","sourceRoot":"","sources":["../../../lib/vocabularies/validation/required.ts"],"names":[],"mappings":"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","sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n"]}},"error":null,"hash":"65b61766eebb54ae93b0b30b57aa9f4e","cacheData":{"env":{}}}